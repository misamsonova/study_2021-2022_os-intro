---
## Front matter
lang: ru-RU
title: Краткий отчёт по лабораторной работе №14
author: Samsonova Maria, Student of RUDN University, Moscow, Russian Federation
institute: RUDN University, Moscow, Russian Federation

Date: 04-06-2022

## Formatting
toc: false
slide_level: 2
theme: metropolis
header-includes: 
 - \metroset{progressbar=frametitle,sectionpage=progressbar,numbering=fraction}
 - '\makeatletter'
 - '\beamer@ignorenonframefalse'
 - '\makeatother'
aspectratio: 43
section-titles: true
---
# Цель выполнения лабораторной работы №14

Приобретение практических навыков работы с именованными каналами.

# Задание

Изучите приведённые в тексте программы server.c и client.c. Взяв данные примеры
за образец, напишите аналогичные программы, внеся следующие изменения:
1. Работает не 1 клиент, а несколько (например, два).
2. Клиенты передают текущее время с некоторой периодичностью (например, раз в пять
секунд). Используйте функцию sleep() для приостановки работы клиента.
3. Сервер работает не бесконечно, а прекращает работу через некоторое время (например, 30 сек). Используйте функцию clock() для определения времени работы сервера.
Что будет в случае, если сервер завершит работу, не закрыв канал?4. 4. 

# Ход выполнения лабораторной работы №14

1. Для начала мы создали необходимые файлы с помощью команды «touch common.h server.c client.c Makefile» и открыли редактор emacs для их редактирования (рис. -@fig:001 ).

![Создание файлов](image/1.png){ #fig:001 width=70% }

2. Далее изменили  коды  программ,  представленных  в  тексте лабораторной работы. В файл common.h добавила стандартные заголовочные файлы unistd.h и time.h,  необходимые  для  работы  кодов  других  файлов. Common.h предназначен для заголовочных файлов, чтобы в остальных программах их не прописывать каждый раз (рис. -@fig:002 ).

![Прграмма в файле common.h](image/2.png){ #fig:002 width=70% }

- В файл server.c добавили цикл while для контроля за временем работы сервера. Разница  между текущим  временем time(NULL) и  временем начала работы clock_t start=time(NULL) (инициализация до цикла) не должна превышать 30 секунд (рис. -@fig:003 , -@fig:004 ).

![Прграмма в файле server.c](image/3.png){ #fig:003 width=70% }

![Прграмма в файле server.c](image/4.png){ #fig:004 width=70% }

- В файл client.c добавили цикл, который отвечает  за  количество сообщений о текущем времени (4 сообщения), которое получается  в результате  выполнения  команд на рис. 7 (/*текущее время*/)  и команду sleep(5) для приостановки работы клиента на 5 секунд (рис. -@fig:005 , -@fig:006 ).

![Прграмма в файле client.c](image/5.png){ #fig:005 width=70% }

![Прграмма в файле client.c](image/6.png){ #fig:006 width=70% }

- Makefile (файл для сборки) не изменяли (рис. -@fig:007 ).

![Прграмма в Mikefile](image/7.png){ #fig:007 width=70% }

3. После написания кодов, используя команду «make all», скомпилировали необходимые файлы (рис. -@fig:008 ).

![Команда make all](image/8.png){ #fig:008 width=70% }

- Далее проверили работу написанного кода. Открыли 3 консоли  (терминала)  и  запустили:  в  первом  терминале − «./server», в остальных двух – «./client». В результате каждый терминал-клиент вывел по 4 сообщения. Спустя 30 секунд работа сервера была прекращена (рис. -@fig:009 ). Программа работает корректно.

![Команда make all](image/9.png){ #fig:009 width=70% }

- Также отдельно  проверили  длительность  работы  сервера,  введя команду «./server»в одном терминале. Он завершил свою работу через 30 секунд (рис. -@fig:010 ). Если сервер завершит свою работу, не закрыв канал, то, когда мы будем запускать  этот  сервер  снова,  появится  ошибка «Невозможно  создать FIFO», так как у нас уже есть один канал.

![Проверка длительности работы сервера](image/10.png){ #fig:010 width=70% }

# Вывод выполнения лабораторной работы №14

В процессе выполнения данной лабораторной работы мы приобрели практические навыки работы с именованными каналами.